<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Reactive Neon Cube | Devan</title>
<style>
  body { margin:0; overflow:hidden; background:#0f0f0f; }
  canvas { display:block; }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/controls/OrbitControls.js"></script>
<script>
  // Scene, Camera, Renderer
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Orbit Controls
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.enableZoom = false;
  controls.enablePan = false;

  // Neon Cube - Wireframe
  const geometry = new THREE.BoxGeometry();
  const edges = new THREE.EdgesGeometry(geometry);
  const cubeMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 2 });
  const cube = new THREE.LineSegments(edges, cubeMaterial);
  scene.add(cube);

  // Glow cube
  const glowGeom = new THREE.BoxGeometry(1.1,1.1,1.1);
  const glowMat = new THREE.MeshBasicMaterial({ color:0x00ffff, transparent:true, opacity:0.2 });
  const glowCube = new THREE.Mesh(glowGeom, glowMat);
  scene.add(glowCube);

  // Floating particles
  const particleCount = 80;
  const particles = [];
  for(let i=0;i<particleCount;i++){
    const pGeom = new THREE.SphereGeometry(0.03, 8, 8);
    const pMat = new THREE.MeshBasicMaterial({color:0x00ffff, transparent:true, opacity:0.6});
    const p = new THREE.Mesh(pGeom,pMat);
    p.position.set((Math.random()-0.5)*4, (Math.random()-0.5)*4, (Math.random()-0.5)*4);
    scene.add(p);
    particles.push(p);
  }

  camera.position.z = 5;

  // Mouse tracking
  const mouse = new THREE.Vector2();
  document.addEventListener('mousemove', (event)=>{
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  });

  // Click pulse
  let pulseTimer = 0;
  document.addEventListener('mousedown', ()=>{
    pulseTimer = 10; // frames of pulse
  });

  // Raycaster for hover
  const raycaster = new THREE.Raycaster();

  function animate(){
    requestAnimationFrame(animate);

    // Cube auto-spin
    cube.rotation.x += 0.002;
    cube.rotation.y += 0.002;
    glowCube.rotation.x = cube.rotation.x;
    glowCube.rotation.y = cube.rotation.y;

    // Particle movement
    particles.forEach((p,i)=>{
      const angle = Date.now()*0.001 + i;
      p.position.x = Math.sin(angle+i)*2;
      p.position.y = Math.cos(angle+i*1.1)*2;
      p.position.z = Math.sin(angle+i*1.2)*2;
    });

    // Particle connecting lines
    particles.forEach((p1,i)=>{
      for(let j=i+1;j<particles.length;j++){
        const p2 = particles[j];
        const dx = p1.position.x-p2.position.x;
        const dy = p1.position.y-p2.position.y;
        const dz = p1.position.z-p2.position.z;
        const dist = Math.sqrt(dx*dx+dy*dy+dz*dz);
        if(dist<0.8){
          const mat = new THREE.LineBasicMaterial({color:0x00ffff, opacity:0.2, transparent:true});
          const points = [p1.position.clone(), p2.position.clone()];
          const geom = new THREE.BufferGeometry().setFromPoints(points);
          const line = new THREE.Line(geom, mat);
          scene.add(line);
          setTimeout(()=>scene.remove(line),0);
        }
      }
    });

    // Hover detection
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(cube);
    if(intersects.length > 0){
      glowMat.opacity = 0.6;
      particles.forEach(p=>p.material.opacity = 1);
    } else {
      glowMat.opacity = 0.2;
      particles.forEach(p=>p.material.opacity = 0.6);
    }

    // Click pulse effect
    if(pulseTimer>0){
      glowMat.opacity = 1;
      particles.forEach(p=>p.material.opacity = 1);
      pulseTimer--;
    }

    controls.update();
    renderer.render(scene,camera);
  }
  animate();

  // Handle resize
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

</body>
</html>
