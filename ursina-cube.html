<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Neon Cube | Devan</title>
<style>
  body { margin:0; overflow:hidden; background:#0f0f0f; }
  canvas { display:block; }
</style>
</head>
<body>

<!-- Three.js + OrbitControls -->
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/controls/OrbitControls.js"></script>
<script>
  // Scene, Camera, Renderer
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Orbit Controls
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.enableZoom = false; // optional: disable zoom
  controls.enablePan = false;  // optional: disable pan

  // Neon Cube - Wireframe
  const geometry = new THREE.BoxGeometry();
  const edges = new THREE.EdgesGeometry(geometry);
  const material = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 2 });
  const cube = new THREE.LineSegments(edges, material);
  scene.add(cube);

  // Glow cube
  const glowGeom = new THREE.BoxGeometry(1.1,1.1,1.1);
  const glowMat = new THREE.MeshBasicMaterial({ color:0x00ffff, transparent:true, opacity:0.2 });
  const glowCube = new THREE.Mesh(glowGeom, glowMat);
  scene.add(glowCube);

  // Floating particles
  const particleCount = 80;
  const particles = [];
  for(let i=0;i<particleCount;i++){
    const pGeom = new THREE.SphereGeometry(0.03, 8, 8);
    const pMat = new THREE.MeshBasicMaterial({color:0x00ffff});
    const p = new THREE.Mesh(pGeom,pMat);
    p.position.set((Math.random()-0.5)*4, (Math.random()-0.5)*4, (Math.random()-0.5)*4);
    scene.add(p);
    particles.push(p);
  }

  camera.position.z = 5;

  // Animate
  function animate(){
    requestAnimationFrame(animate);

    // Cube auto spin (subtle) if you want
    cube.rotation.x += 0.002;
    cube.rotation.y += 0.002;
    glowCube.rotation.x = cube.rotation.x;
    glowCube.rotation.y = cube.rotation.y;

    // Particle orbit
    particles.forEach((p,i)=>{
      const angle = Date.now()*0.001 + i;
      p.position.x = Math.sin(angle+i)*2;
      p.position.y = Math.cos(angle+i*1.1)*2;
      p.position.z = Math.sin(angle+i*1.2)*2;
    });

    // Connecting lines
    particles.forEach((p1,i)=>{
      for(let j=i+1;j<particles.length;j++){
        const p2 = particles[j];
        const dx = p1.position.x-p2.position.x;
        const dy = p1.position.y-p2.position.y;
        const dz = p1.position.z-p2.position.z;
        const dist = Math.sqrt(dx*dx+dy*dy+dz*dz);
        if(dist<0.8){
          const mat = new THREE.LineBasicMaterial({color:0x00ffff, opacity:0.2, transparent:true});
          const points = [p1.position.clone(), p2.position.clone()];
          const geom = new THREE.BufferGeometry().setFromPoints(points);
          const line = new THREE.Line(geom, mat);
          scene.add(line);
          setTimeout(()=>scene.remove(line),0);
        }
      }
    });

    controls.update();
    renderer.render(scene,camera);
  }
  animate();

  // Handle resize
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

</body>
</html>
